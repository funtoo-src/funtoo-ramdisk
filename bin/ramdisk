#!/usr/bin/python3

import asyncio
import os
import re
import subprocess
import sys
import tempfile
from collections import defaultdict

from rich.console import Console
from rich.highlighter import RegexHighlighter
from rich.theme import Theme

from_git = False

f_path = os.path.dirname(os.path.realpath(__file__))
proj_path = os.path.normpath(os.path.join(f_path, "../.git"))
mod_path = None
if os.path.isdir(proj_path):
	base_path = os.path.normpath(os.path.join(proj_path, "../"))
	mod_path = os.path.join(base_path, "funtoo_ramdisk")
	support_path = os.path.join(mod_path, "support")
	if not os.path.exists(mod_path):
		raise FileNotFoundError(f"from_git: Did not find {mod_path} where I expected to find it.")
	if not os.path.exists(support_path):
		raise FileNotFoundError(f"from_git: Did not find {support_path} where I expected to find it.")
	from_git = True
	sys.path.insert(0, base_path)
	support_root = os.path.join(mod_path, "support")

if not from_git:
	# import the module just to use it to get the path to the files.
	import funtoo_ramdisk
	support_root = os.path.normpath(os.path.join(funtoo_ramdisk.__file__, "../support"))

from funtoo_ramdisk.initramfs import InitialRamDisk
from funtoo_ramdisk.config_files import ConfigFstab
from funtoo_ramdisk.version import __version__

if from_git:
	__version__ += "+git"

ACTIONS = {
	"build": None,
	"kernel": ["list"],
	"plugins": ["list"]
}

ACTION_KEYS = set(sorted(ACTIONS.keys()))

OPTIONAL_ARGS = {
	"--debug": False,
	"--backtrace": False,
	"--force": False,
	"--help": False,
}

BUILD_SETTINGS = {
	"--kernel": None,
	"--compression": "xz",
	"--fs_root": "/",
	"--temp_root": "/var/tmp",
	"--enable": "",
	"--modconfig": "full",
	"--kpop": None,
}

# 	"version": {"action": "version", "version": f"funtoo-ramdisk {__version__}"},
BUILD_CLI_ARGS ={
	"destination": {"default": None, "action": "store", "positional": True, "help": "The output initramfs filename to create."},
}


class OptionalArgs:

	default = None

	def __init__(self, default_dict=None, default=False):
		self.default = default
		self.changed_keys = set()
		if default_dict:
			self.set_defaults(default_dict)

	def set_defaults(self, default_dict):
		# If we have a dictionary, treat it as a bunch of default values for a bunch of settings:
		for key, val in default_dict.items():
			setattr(self, key.lstrip('-'), val)

	def set_value(self, key, value):
		"""
		Use this method to set any value!!!

		You can specify key as "--foobar" or "foobar".
		"""
		self.changed_keys.add(key)
		setattr(self, key.lstrip('-'), value)

	def __getattr__(self, item):
		return self.default

	def __repr__(self):
		return f"<OptionalArgs: keys: {sorted(list(self.changed_keys))}>"


class ArgParseError(Exception):
	pass


def parse_opt_args(argv, find_opt_args, existing_opt_args=None):
	"""
	This is a key part of our custom argument parser. Given input arguments ``argv``, scan these arguments
	for any optional arguments specified in ``find_opt_args``, which is a dictionary of key/value pairs of
	options. Keys are literal "--foobar" values, and values in the dict can be used to set default values.

	An ``OptionalArgs`` object is returned with the found optional values set to ``True``. You can also
	pass in an ``existing_opt_args`` object if you want to collect all your optional toggles in a single
	object. Any not-specified argument will have a ``False`` default value.

	This function returns the optional arguments object, as well as any extra, unparsed arguments, which
	could require further parsing, or potentially be invalid, unrecognized arguments.
	"""
	pos = 0
	# parse main arguments -- optional and leftover actions:
	if existing_opt_args:
		opt_args = existing_opt_args
		opt_args.set_defaults(find_opt_args)
	else:
		opt_args = OptionalArgs(default=False, default_dict=find_opt_args)
	extra_args = []
	while pos < len(argv):
		arg = argv[pos]
		if arg in find_opt_args.keys():
			opt_args.set_value(arg.lstrip("-"), True)
		else:
			extra_args.append(arg)
		pos += 1
	return opt_args, extra_args


def parse_opt_settings(argv, find_opt_settings, existing_opt_args=None):
	"""
	This function is very similar to ``find_opt_args``, above, but we assume that if any of these
	optional settings are specified, they also come along with a value, either in the form of
	``--foo=bar`` or ``--foo bar``. The command-line-supplied value is stored as a string in an
	optional arguments object, which is returned with any unparsed/unrecognized arguments.
	"""
	pos = 0
	# parse main arguments -- optional and leftover actions:
	if existing_opt_args:
		opt_args = existing_opt_args
		opt_args.set_defaults(find_opt_settings)
	else:
		opt_args = OptionalArgs(default=False, default_dict=find_opt_settings)
	extra_args = []
	while pos < len(argv):
		arg = argv[pos]
		eq_pos = arg.find("=")
		if eq_pos == -1:
			# next argument is the value
			pos += 1
			if arg not in find_opt_settings:
				extra_args.append(arg)
				continue
			if pos >= len(argv):
				raise ArgParseError(f"Command-line setting '{arg}' requires a value, set with either '{arg}=val' or '{arg} val'")
			arg_key = arg
			arg_val = argv[pos]
		else:
			# include --foo=bar value:
			arg_key = arg[:eq_pos]
			arg_val = arg[eq_pos+1:]
		if arg_key in find_opt_settings:
			opt_args.set_value(arg_key.lstrip('-'), arg_val)
		else:
			extra_args.append(arg)
		pos += 1
	return opt_args, extra_args


def parse_action(argv, actions, default_action=None):
	"""
	Given input arguments ``argv``, and a set of possible valid actions inside ``actions``, and a possible
	default action specified in ``default_action``, parse all input arguments, and return the detected action,
	plus any unparsed/unrecognized arguments.

	``ArgParseError`` will be thrown if:

	1. More than one valid action specified.
	2. No action specified, and no default action.
	"""
	action = None
	extra_args = []
	for arg in argv:
		if arg in actions:
			if action:
				raise ArgParseError(f"Duplicate action '{arg}' -- '{action}' already specified.")
			else:
				action = arg
		else:
			# This could be sub-options for a specific action:
			extra_args.append(arg)
	if action is None:
		if default_action:
			action = default_action
		else:
			raise ArgParseError(f"No action specified. Specify one of: {' '.join(sorted(actions))}")
	return action, extra_args


class FakeLogger:
	class MyHighlighter(RegexHighlighter):
		base_style = "ramdisk."
		highlights = [r"(?P<stats>^ ::.*)"]

	def __init__(self, debug=False):
		self.theme = Theme({"ramdisk.stats": "bold magenta"})
		self.console = Console(highlighter=None, theme=self.theme)
		self.debug_mode = debug

	def enable_debug(self):
		self.debug_mode = True

	def info(self, msg):
		self.console.print(" [turquoise2]::[default] " + msg)

	def warning(self, msg):
		self.console.print(" [orange1]::[default] " + msg)

	def error(self, msg):
		self.console.print(" [bright_white on dark_red]:collision::collision:[default] " + msg + " ")

	def done(self, msg):
		self.console.print(" [light_salmon1]:sparkle::sparkle:[default] " + msg)

	def debug(self, msg):
		if not self.debug_mode:
			return
		self.console.log(msg)

	def print_exception(self, show_locals=False):
		self.console.print_exception(show_locals=show_locals)


def get_kernel_version_from_symlink(kernel_link):
	"""
	Provide a symlink, which could be either ``/usr/src/linux`` or ``/lib/modules/<kv>/sources``, and this will extract
	the version info from the Makefile, and return it as a single formatted string containing the full kernel
	version.

	Typically, modules for this kernel can be found at ``/lib/modules/<kernel version>``.
	"""
	link_target = os.readlink(kernel_link)
	link_target = os.path.join(os.path.dirname(kernel_link), link_target)
	if not os.path.exists(link_target):
		raise FileNotFoundError(f"Could not find kernel from symlink {kernel_link} -- looking for {link_target} symlink target.")
	# grab data from Makefile, so we can determine correct kernel name for finding modules:
	datums = ["VERSION", "PATCHLEVEL", "SUBLEVEL", "EXTRAVERSION"]
	got_datums = {}
	with open(os.path.join(link_target, "Makefile"), "r") as mkf:
		while len(got_datums.keys()) != 4:
			line = mkf.readline()
			if not line:
				break
			for datum in datums:
				if datum not in got_datums:
					if line.startswith(f"{datum} ="):
						got_datums[datum] = line.split("=")[1].strip()
	if len(got_datums.keys()) != 4:
		raise ValueError(f"Could not extract: {datums} from {kernel_link}/Makefile.")
	return "{VERSION}.{PATCHLEVEL}.{SUBLEVEL}{EXTRAVERSION}".format(**got_datums)


def get_modpath_and_kv_from_linux_symlink():
	kernel_link = os.path.join(args.fs_root, "usr/src/linux")
	log.info(f"No kernel specified, so going to try to use [turquoise2]{kernel_link}[default] symlink.")
	if not os.path.islink(kernel_link):
		raise FileNotFoundError(f"{kernel_link} does not exist or is not a symlink.")

	kernel_version = get_kernel_version_from_symlink(kernel_link)

	module_path = os.path.join(args.fs_root, f"lib/modules/{kernel_version}")
	if not os.path.exists(module_path):
		raise FileNotFoundError(f"Expected kernel module path {module_path} not found.")
	return module_path, kernel_version


def get_current_kernel_version():
	status, current_version = subprocess.getstatusoutput("uname -r")
	return current_version.strip()


def fstab_sanity_check():
	fstab = ConfigFstab()
	root_entry = fstab.get_line_by_mount("/")
	if re.match("^/dev/sd.*", root_entry[0]):
		cmd = f"/sbin/blkid -s UUID -o value {root_entry[0]}"
		status, uuid = subprocess.getstatusoutput(cmd)
		if status != 0:
			raise ValueError(f"command: '{cmd}' failed with exit code {status}.")
		uuid = uuid.strip()
		if not uuid:
			raise ValueError(f"command: '{cmd}' was unable to give us a UUID.")
		log.warning(f"""Detected root device {root_entry[0]}, which could be a problem if you have more
	than one ATA/SCSI disk. Since /dev/sd* device nodes are not consistently 
	assigned, the initramfs could see this as a different device. Please do the the
	following:

	1. In /etc/fstab, change your root entry from:

	   {'    '.join(root_entry)} 

	   to:

	   UUID={uuid}    {'    '.join(root_entry[1:])}

	2. *Re-run* ego boot update so that GRUB will look for your root block device
	    by UUID.

	3. This problem should now be resolved, since now you are referring to the root
	   block device using a UUID which will not change. Now, go ahead and try to
	   create your ramdisk again.
		""")


async def main_thread(action: str, opt_args: OptionalArgs, extra_args):
	log.warning(f"[turquoise2]funtoo-ramdisk [orange1]{__version__}[default] [grey63]:wolf:[default]")
	if from_git:
		log.info(f"Running from git repository [turquoise2]{os.path.dirname(proj_path)}[default]")

	if action == "help":
		help()
		sys.exit(1)

	kernel_version = get_kernel_version_from_symlink("/usr/src/linux")
	current_version = get_current_kernel_version()
	if kernel_version == current_version:
		log.info(f"Found: [orange1]{kernel_version}[default] (currently-active kernel)")
	else:
		log.info(
			f"Found: [orange1]{kernel_version}[default] (currently-active kernel is: [bright cyan]{current_version}[default]).")
	if opt_args.kpop is None:
		kpop = None
	else:
		kpop = opt_args.kpop.split(',')
		# --kpop implies "--modconfig=kpop"
		opt_args.modconfig = "kpop"
	with tempfile.TemporaryDirectory(prefix="ramdisk-", dir=opt_args.temp_root) as temp_dir:
		ramdisk = InitialRamDisk(
			action=action,
			temp_root=temp_dir,
			support_root=support_root,
			kernel_version=kernel_version,
			compression=opt_args.compression,
			modules_root=opt_args.fs_root,
			logger=log,
			pypath=mod_path,
			enabled_plugins=opt_args.enable.split(","),
			modconfig=opt_args.modconfig,
			kpop=kpop
		)
		if action == "build":
			if len(extra_args) == 0:
				raise ArgParseError("Expecting a destination to be specified for the output initramfs.")
			elif len(extra_args) > 1:
				raise ArgParseError(f"Unrecognized arguments: {' '.join(extra_args[1:])}")
			output_initramfs = os.path.abspath(extra_args[-1])
			if os.path.exists(output_initramfs) and not opt_args.force:
				raise FileExistsError("Specified destination initramfs already exists -- use --force to overwrite.")
			fstab_sanity_check()
			return ramdisk.create_ramdisk(output_initramfs)
		else:
			raise ValueError(f"Action {action} not yet supported.")


def help():
	print("help!")


if __name__ == "__main__":
	log = FakeLogger()
	opt_args = None

	# Get optional args, and actions/unknown args in extra_args:
	try:
		opt_args, extra_args = parse_opt_args(sys.argv[1:], OPTIONAL_ARGS)
		action, extra_args = parse_action(extra_args, ACTION_KEYS, default_action="build")
		if opt_args.help:
			action = "help"
		elif action == "build":
			opt_args, extra_args = parse_opt_settings(extra_args, BUILD_SETTINGS, existing_opt_args=opt_args)
		if opt_args.debug:
			log.info("DEBUG enabled.")
			log.enable_debug()
		if opt_args.backtrace:
			from rich.traceback import install
			install(show_locals=True)

		success = asyncio.run(main_thread(action, opt_args, extra_args))
	except Exception as e:
		log.error(f"{e.__class__.__name__}: {e}")
		if opt_args and opt_args.backtrace:
			log.print_exception(show_locals=False)
		success = False
	if not success:
		sys.exit(1)
