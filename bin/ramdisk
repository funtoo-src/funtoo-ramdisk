#!/usr/bin/python3

import asyncio
import os
import re
import subprocess
import sys
import tempfile

from_git = False

f_path = os.path.dirname(os.path.realpath(__file__))
proj_path = os.path.normpath(os.path.join(f_path, "../.git"))
mod_path = None
if os.path.isdir(proj_path):
	base_path = os.path.normpath(os.path.join(proj_path, "../"))
	mod_path = os.path.join(base_path, "funtoo_ramdisk")
	support_path = os.path.join(mod_path, "support")
	if not os.path.exists(mod_path):
		raise FileNotFoundError(f"from_git: Did not find {mod_path} where I expected to find it.")
	if not os.path.exists(support_path):
		raise FileNotFoundError(f"from_git: Did not find {support_path} where I expected to find it.")
	from_git = True
	sys.path.insert(0, base_path)
	support_root = os.path.join(mod_path, "support")

if not from_git:
	# import the module just to use it to get the path to the files.
	import funtoo_ramdisk
	support_root = os.path.normpath(os.path.join(funtoo_ramdisk.__file__, "../support"))

from funtoo_ramdisk.initramfs import InitialRamDisk
from funtoo_ramdisk.config_files import ConfigFstab
from funtoo_ramdisk.version import __version__
from funtoo_ramdisk.const import ACTION_KEYS, OPTIONAL_ARGS, BUILD_SETTINGS
from funtoo_ramdisk.args import OptionalArgs, ArgParseError, parse_opt_args, parse_opt_settings, parse_action
from funtoo_ramdisk.log import FakeLogger


if from_git:
	__version__ += "+git"


def get_kernel_version_from_symlink(kernel_link):
	"""
	Provide a symlink, which could be either ``/usr/src/linux`` or ``/lib/modules/<kv>/sources``, and this will extract
	the version info from the Makefile, and return it as a single formatted string containing the full kernel
	version.

	Typically, modules for this kernel can be found at ``/lib/modules/<kernel version>``.
	"""
	link_target = os.readlink(kernel_link)
	link_target = os.path.join(os.path.dirname(kernel_link), link_target)
	if not os.path.exists(link_target):
		raise FileNotFoundError(f"Could not find kernel from symlink {kernel_link} -- looking for {link_target} symlink target.")
	# grab data from Makefile, so we can determine correct kernel name for finding modules:
	datums = ["VERSION", "PATCHLEVEL", "SUBLEVEL", "EXTRAVERSION"]
	got_datums = {}
	with open(os.path.join(link_target, "Makefile"), "r") as mkf:
		while len(got_datums.keys()) != 4:
			line = mkf.readline()
			if not line:
				break
			for datum in datums:
				if datum not in got_datums:
					if line.startswith(f"{datum} ="):
						got_datums[datum] = line.split("=")[1].strip()
	if len(got_datums.keys()) != 4:
		raise ValueError(f"Could not extract: {datums} from {kernel_link}/Makefile.")
	return "{VERSION}.{PATCHLEVEL}.{SUBLEVEL}{EXTRAVERSION}".format(**got_datums)


def get_modpath_and_kv_from_linux_symlink():
	kernel_link = os.path.join(args.fs_root, "usr/src/linux")
	log.info(f"No kernel specified, so going to try to use [turquoise2]{kernel_link}[default] symlink.")
	if not os.path.islink(kernel_link):
		raise FileNotFoundError(f"{kernel_link} does not exist or is not a symlink.")

	kernel_version = get_kernel_version_from_symlink(kernel_link)

	module_path = os.path.join(args.fs_root, f"lib/modules/{kernel_version}")
	if not os.path.exists(module_path):
		raise FileNotFoundError(f"Expected kernel module path {module_path} not found.")
	return module_path, kernel_version


def get_current_kernel_version():
	status, current_version = subprocess.getstatusoutput("uname -r")
	return current_version.strip()


def fstab_sanity_check():
	fstab = ConfigFstab()
	try:
		root_entry = fstab.get_line_by_mount("/")
	except KeyError:
		log.warning("Cannot find '/' mount point in /etc/fstab -- assuming not-yet-configured system or metro build.")
		return
	if re.match("^/dev/sd.*", root_entry[0]):
		cmd = f"/sbin/blkid -s UUID -o value {root_entry[0]}"
		status, uuid = subprocess.getstatusoutput(cmd)
		if status != 0:
			raise ValueError(f"command: '{cmd}' failed with exit code {status}.")
		uuid = uuid.strip()
		if not uuid:
			raise ValueError(f"command: '{cmd}' was unable to give us a UUID.")
		log.warning(f"""Detected root device {root_entry[0]}, which could be a problem if you have more
	than one ATA/SCSI disk. Since /dev/sd* device nodes are not consistently 
	assigned, the initramfs could see this as a different device. Please do the the
	following:

	1. In /etc/fstab, change your root entry from:

	   {'    '.join(root_entry)} 

	   to:

	   UUID={uuid}    {'    '.join(root_entry[1:])}

	2. *Re-run* ego boot update so that GRUB will look for your root block device
	    by UUID.

	3. This problem should now be resolved, since now you are referring to the root
	   block device using a UUID which will not change. Now, go ahead and try to
	   create your ramdisk again.
		""")


async def main_thread(action: str, opt_args: OptionalArgs, extra_args):
	log.warning(f"[turquoise2]funtoo-ramdisk [orange1]{__version__}[default] [grey63]:wolf:[default]")
	if from_git:
		log.info(f"Running from git repository [turquoise2]{os.path.dirname(proj_path)}[default]")

	if action == "help":
		help()
		sys.exit(1)

	kernel_version = get_kernel_version_from_symlink("/usr/src/linux")
	current_version = get_current_kernel_version()
	if kernel_version == current_version:
		log.info(f"Found: [orange1]{kernel_version}[default] (currently-active kernel)")
	else:
		log.info(
			f"Found: [orange1]{kernel_version}[default] (currently-active kernel is: [bright cyan]{current_version}[default]).")
	if opt_args.kpop is None:
		kpop = None
	else:
		kpop = opt_args.kpop.split(',')
		# --kpop implies "--modconfig=kpop"
		opt_args.modconfig = "kpop"
	with tempfile.TemporaryDirectory(prefix="ramdisk-", dir=opt_args.temp_root) as temp_dir:
		ramdisk = InitialRamDisk(
			action=action,
			temp_root=temp_dir,
			support_root=support_root,
			kernel_version=kernel_version,
			compression=opt_args.compression,
			modules_root=opt_args.fs_root,
			logger=log,
			pypath=mod_path,
			enabled_plugins=opt_args.enable.split(","),
			modconfig=opt_args.modconfig,
			kpop=kpop
		)
		if action == "build":
			if len(extra_args) == 0:
				raise ArgParseError("Expecting a destination to be specified for the output initramfs.")
			elif len(extra_args) > 1:
				raise ArgParseError(f"Unrecognized arguments: {' '.join(extra_args[1:])}")
			output_initramfs = os.path.abspath(extra_args[-1])
			if os.path.exists(output_initramfs) and not opt_args.force:
				raise FileExistsError("Specified destination initramfs already exists -- use --force to overwrite.")
			fstab_sanity_check()
			return ramdisk.create_ramdisk(output_initramfs)
		else:
			raise ValueError(f"Action {action} not yet supported.")


def help():
	print("help!")


if __name__ == "__main__":
	log = FakeLogger()
	opt_args = None

	# Get optional args, and actions/unknown args in extra_args:
	try:
		opt_args, extra_args = parse_opt_args(sys.argv[1:], OPTIONAL_ARGS)
		action, extra_args = parse_action(extra_args, ACTION_KEYS, default_action="build")
		if opt_args.help:
			action = "help"
		elif action == "build":
			opt_args, extra_args = parse_opt_settings(extra_args, BUILD_SETTINGS, existing_opt_args=opt_args)
		if opt_args.debug:
			log.info("DEBUG enabled.")
			log.enable_debug()
		if opt_args.backtrace:
			from rich.traceback import install
			install(show_locals=True)

		success = asyncio.run(main_thread(action, opt_args, extra_args))
	except Exception as e:
		log.error(f"{e.__class__.__name__}: {e}")
		if opt_args and opt_args.backtrace:
			log.print_exception(show_locals=False)
		success = False
	if not success:
		sys.exit(1)
